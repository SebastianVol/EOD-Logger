//*************************************************************************
// Two channel EOD logger programm for testing purposes
// Barebone: no RTC
//*************************************************************************

#include <ADC.h>              //library for easier ADC implementation
#include <DMAChannel.h>       //library for easier DMA implementation
#include <array>              //use C++ array structs
#include <SdFat.h>            // work with SD card

#define BUF_DIM  256 //16384       //size of buffer that holds data from ADC
#define NO_BUFFERS 30

/*----------------------------------------------------------------*/
/*
const uint32_t pdbfreq = 10000;  // sampling speed [Hz] max ~300MHz - actually the trigger frequency of the programmable delay block
uint32_t duration = 60;           // duration of each measure-cycle [s]
String Name = "Log";              // file name prefix

/*----------------------------------------------------------------*/

/*DECLARATIONS adc and pins---------------------------------------*/
  ADC *adc = new ADC();            // used to declare the adc->### object

/*PINS------------------------------------------------------------*/
const uint16_t ChannelsCfg_0 [] =  { 0x46, 0x47, 0x4F, 0x44 };  //ADC0: A6, A7, A8, A9 

/*----------------------------------------------------------------*/

/*Buffer declarations----------------------------------------------*/
DMAMEM static volatile uint16_t __attribute__((aligned(BUF_DIM))) buffer[NO_BUFFERS][BUF_DIM];     // size of buffer is limited due to the Teensy's program memory
volatile int ibuf_0;
unsigned long debug_start;
/*
uint32_t      FILE_SIZE     = 0;                                                  //initial variables for filesize and pointer to...
uint32_t      last          = 0;     
uint32_t      last1         = 0;     
uint32_t      bytes         = 0;
float         preceil       = 0;
float         scale         = 0;
/*----------------------------------------------------------------*/

/*DECLARATIONS dma and tcd----------------------------------------*/
DMAChannel dma;                                 // used to declare the dma.### object for the first channel
DMAChannel dma_switch;
                           
/*----------------------------------------------------------------*/


/*DECLARATIONS microSD card files---------------------------------*/

/*----------------------------------------------------------------*/


// function creates new files for data logging
/*----------------------------------------------------------------*/

void setup() 
{
  /*Serial monitor--------------------------------------------------*/
  debug_start = millis();
  Serial.begin(115200);
  while (!Serial && ((millis() - debug_start) <= 5000));
  Serial.println("Begin Setup\n");
  /*----------------------------------------------------------------*/
  ibuf_0 = 0;


  /*Mode Setup------------------------------------------------------*/
  pinMode(13, OUTPUT); // built-in LED is at PIN 13 in Teensy 3.5

    // clear buffer
  for (int i = 0; i < NO_BUFFERS; ++i){
    for (int j = 0; j < BUF_DIM; ++j){
      buffer[i][j] = 50000;

    }
  }


  /*----------------------------------------------------------------*/
  setup_adc();
  setup_dma(); 

  /*Debug-----------------------------------------------------------*/
  Serial.println(BUF_DIM);
  //Serial.println(FILE_SIZE);
  //Serial.print("bytes: ");
  //Serial.println(bytes);
  Serial.println((uint32_t)&buffer[ 0], HEX);                               // debug: print memory location of buffer
  Serial.println((uint32_t)&buffer[ 16 * 512], HEX);
  Serial.println((uint32_t)&buffer[ 32 * 512], HEX);
  Serial.println((uint32_t)&buffer[ 48 * 512], HEX);

  Serial.println("----------------------------------");
  /*----------------------------------------------------------------*/

  /*Signal end of Setup method--------------------------------------*/
  for (int i = 0; i < 5; i++){                                             // visual feedback, blink 5 times if the setup was completed
    digitalWrite(13, HIGH);
    delay(300);
    digitalWrite(13, LOW);
    delay(300);
  }


}


void loop() { 

  //const uint8_t sc1a_pin = channel2sc1a[A8];
  //Serial.println(sc1a_pin);

  for (int i = 0; i < 10; i++){
  

  Serial.print(i);
  Serial.print(".....");
  Serial.println(buffer[0][i]);
  }
  delay(100);
  /*
  while ( ((64*1024-1) & ( (int)dma.TCD->DADDR - last )) > BUF_DIM ){  
    if (BUF_DIM != (uint32_t)file.write( (char*)&buffer[((last/2)&(32*1024-1))], BUF_DIM) ){ 
      sd.errorHalt("write dma0 failed");    
      }
    last += BUF_DIM ;  
    
    if (BUF_DIM != (uint32_t)file1.write( (char*)&buffer1[((last1/2)&(32*1024-1))], BUF_DIM) ){ 
      sd.errorHalt("write dma1 failed");
      }
    last1 += BUF_DIM ;
  } 
  /*----------------------------------------------------------------*/
  /*
  if ( last >= FILE_SIZE ) {                                              // check if end of file is reached
    file.close();
    last = 0;                                                             // reset last
    filestuff();                                                          // create new files for data logging
  }
  if ( last1 >= FILE_SIZE ) {                                              // check if end of file is reached
    file1.close();
    last1 = 0;                                                             // reset last
    filestuff1();                                                          // create new files for data logging
  }
  /*----------------------------------------------------------------*/
}

void setup_adc() {

  adc->adc0->setResolution      (                  12  );
  adc->adc0->setReference       (ADC_REFERENCE::REF_3V3);  

  ADC1_CFG2 |= ADC_CFG2_MUXSEL;

  adc->adc0->enableDMA();                                                     // connect DMA and ADC
 
  ADC0_SC1A = ChannelsCfg_0 [0];

}

void setup_dma(){
  dma.begin(true);
  dma.TCD->SADDR    =          &ADC0_RA;
  dma.TCD->SOFF     =                 0;            // source increment each transfer
  dma.TCD->ATTR     =             0x101;
  dma.TCD->NBYTES   =                 2;
  dma.TCD->SLAST    =                 0;
  dma.TCD->DADDR    =     &buffer[0][0];
  dma.TCD->DOFF     =                 2; 
  dma.TCD->DLASTSGA =        -2*BUF_DIM; 
  dma.TCD->CITER    =           BUF_DIM;
  dma.TCD->BITER    =           BUF_DIM;
  dma.triggerAtHardwareEvent (DMAMUX_SOURCE_ADC0); 
  dma.disableOnCompletion();
  dma.interruptAtCompletion();
  dma.attachInterrupt(dma_isr);

  dma_switch.begin(true);
  dma_switch.TCD->SADDR = &ChannelsCfg_0[0];
  dma_switch.TCD->SOFF = 2;            // source increment each transfer (n bytes)
  dma_switch.TCD->ATTR = 0x101;
  dma_switch.TCD->SLAST = -8;          // num ADC0 samples * 2
  dma_switch.TCD->BITER = 4;           // num of ADC0 samples
  dma_switch.TCD->CITER = 4;           // num of ADC0 samples
  dma_switch.TCD->DADDR = &ADC0_SC1A;
  dma_switch.TCD->DLASTSGA = 0;
  dma_switch.TCD->NBYTES = 2;
  dma_switch.TCD->DOFF = 0;
  dma_switch.triggerAtTransfersOf(dma);
  dma_switch.triggerAtCompletionOf(dma);

    // configure TCD for first dma


  dma.enable();                                                             // enable DMA
  dma_switch.enable();

  
}

void dma_isr(void) {
    ibuf_0=(ibuf_0+1) % NO_BUFFERS;
    dma.TCD->DADDR = &buffer[ibuf_0][0];
    dma.clearInterrupt();
    dma.enable();
}
